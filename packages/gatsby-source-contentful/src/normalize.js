// @ts-check
import stringify from "json-stringify-safe"
import _ from "lodash"
import { getGatsbyVersion } from "gatsby-core-utils"
import { lt, prerelease } from "semver"

const typePrefix = `Contentful`
const makeTypeName = type => _.upperFirst(_.camelCase(`${typePrefix} ${type}`))

const GATSBY_VERSION_MANIFEST_V2 = `4.3.0`
const gatsbyVersion =
  (typeof getGatsbyVersion === `function` && getGatsbyVersion()) || `0.0.0`
const gatsbyVersionIsPrerelease = prerelease(gatsbyVersion)
const shouldUpgradeGatsbyVersion =
  lt(gatsbyVersion, GATSBY_VERSION_MANIFEST_V2) && !gatsbyVersionIsPrerelease

export const getLocalizedField = ({ field, locale, localesFallback }) => {
  if (!_.isUndefined(field[locale.code])) {
    return field[locale.code]
  } else if (
    !_.isUndefined(locale.code) &&
    !_.isUndefined(localesFallback[locale.code])
  ) {
    return getLocalizedField({
      field,
      locale: { code: localesFallback[locale.code] },
      localesFallback,
    })
  } else {
    return null
  }
}
export const buildFallbackChain = locales => {
  const localesFallback = {}
  _.each(
    locales,
    locale => (localesFallback[locale.code] = locale.fallbackCode)
  )
  return localesFallback
}
const makeGetLocalizedField =
  ({ locale, localesFallback }) =>
  field =>
    getLocalizedField({ field, locale, localesFallback })

export const makeId = ({ spaceId, id, currentLocale, defaultLocale, type }) => {
  const normalizedType = type.startsWith(`Deleted`)
    ? type.substring(`Deleted`.length)
    : type

  // @todo no need for this extra logic, just keep the locale and remove default
  return currentLocale === defaultLocale
    ? `${spaceId}___${id}___${normalizedType}`
    : `${spaceId}___${id}___${normalizedType}___${currentLocale}`
}

const makeMakeId =
  ({ currentLocale, defaultLocale, createNodeId }) =>
  (spaceId, id, type) =>
    createNodeId(makeId({ spaceId, id, currentLocale, defaultLocale, type }))

export const buildResolvableSet = ({ entries = [], assets = [] }) =>
  new Set([...entries, ...assets].map(n => `${n.sys.id}___${n.sys.type}`))

export const buildContentTypeMap = ({
  contentTypeItems,
  restrictedNodeFields,
  conflictFieldPrefix,
  useNameForId,
}) => {
  const contentTypeMap = new Map()
  for (let i = 0; i < contentTypeItems.length; i++) {
    const contentTypeItem = contentTypeItems[i]

    // Establish identifier for content type
    //  Use `name` if specified, otherwise, use internal id (usually a natural-language constant,
    //  but sometimes a base62 uuid generated by Contentful, hence the option)
    let normalizedContentTypeId = contentTypeItem.sys.id
    if (useNameForId) {
      normalizedContentTypeId = contentTypeItem.name.toLowerCase()
    }

    // Warn about any field conflicts
    const conflictFields = []
    contentTypeItem.fields.forEach(contentTypeItemField => {
      const fieldName = contentTypeItemField.id
      if (restrictedNodeFields.includes(fieldName)) {
        console.log(
          `Restricted field found for ContentType ${normalizedContentTypeId} and field ${fieldName}. Prefixing with ${conflictFieldPrefix}.`
        )
        conflictFields.push(fieldName)
      }
    })

    contentTypeMap.set(contentTypeItem.sys.id, {
      normalizedContentTypeId,
      conflictFields,
      contentTypeItem,
    })
  }
  return contentTypeMap
}

export const buildForeignReferenceMap = ({
  contentTypeMap,
  entries,
  resolvable,
  defaultLocale,
  space,
}) => {
  const foreignReferenceMap = {}

  entries.forEach(entryItem => {
    const entryItemFields = entryItem.fields

    // Establish identifier for content type
    //  Use `name` if specified, otherwise, use internal id (usually a natural-language constant,
    //  but sometimes a base62 uuid generated by Contentful, hence the option)
    const contentTypeItemId = contentTypeMap.get(
      entryItem.sys.contentType.sys.id
    ).normalizedContentTypeId

    Object.keys(entryItemFields).forEach(entryItemFieldKey => {
      // @todo this seems not to cover translateable reference fields
      // loop by locales?
      const entryItemFieldValue =
        entryItemFields[entryItemFieldKey][defaultLocale]

      // If this is an array of single reference object
      // add to the reference map, otherwise ignore.

      if (Array.isArray(entryItemFieldValue)) {
        if (entryItemFieldValue[0]?.sys?.type === `Link`) {
          entryItemFieldValue.forEach(v => {
            const key = `${v.sys.id}___${v.sys.linkType || v.sys.type}`
            // Don't create link to an unresolvable field.
            if (!resolvable.has(key)) {
              return
            }

            if (!foreignReferenceMap[key]) {
              foreignReferenceMap[key] = []
            }
            foreignReferenceMap[key].push({
              name: `${contentTypeItemId}___NODE`,
              id: entryItem.sys.id,
              spaceId: space.sys.id,
              type: entryItem.sys.type,
            })
          })
        }
      } else if (entryItemFieldValue?.sys?.type === `Link`) {
        const key = `${entryItemFieldValue.sys.id}___${
          entryItemFieldValue.sys.linkType || entryItemFieldValue.sys.type
        }`
        // Don't create link to an unresolvable field.
        if (!resolvable.has(key)) {
          return
        }

        if (!foreignReferenceMap[key]) {
          foreignReferenceMap[key] = []
        }
        foreignReferenceMap[key].push({
          name: `${contentTypeItemId}___NODE`,
          id: entryItem.sys.id,
          spaceId: space.sys.id,
          type: entryItem.sys.type,
        })
      }
    })
  })

  return foreignReferenceMap
}

function prepareTextNode(id, node, key, text) {
  const str = _.isString(text) ? text : ``
  const textNode = {
    id,
    parent: node.id,
    children: [],
    [key]: str,
    internal: {
      type: _.camelCase(`${node.internal.type} ${key} TextNode`),
      mediaType: `text/markdown`,
      content: str,
      // entryItem.sys.updatedAt is source of truth from contentful
      contentDigest: node.updatedAt,
    },
    sys: {
      type: node.sys.type,
    },
  }

  node.children = node.children.concat([id])

  return textNode
}

function prepareJSONNode(id, node, key, content) {
  const str = JSON.stringify(content)
  const JSONNode = {
    ...(_.isPlainObject(content) ? { ...content } : { content: content }),
    id,
    parent: node.id,
    children: [],
    internal: {
      type: _.camelCase(`${node.internal.type} ${key} JSONNode`),
      mediaType: `application/json`,
      content: str,
      // entryItem.sys.updatedAt is source of truth from contentful
      contentDigest: node.updatedAt,
    },
    sys: {
      type: node.sys.type,
    },
  }

  node.children = node.children.concat([id])

  return JSONNode
}

let numberOfContentSyncDebugLogs = 0
const maxContentSyncDebugLogTimes = 50

let warnOnceForNoSupport = false
let warnOnceToUpgradeGatsby = false

/**
 * This fn creates node manifests which are used for Gatsby Cloud Previews via the Content Sync API/feature.
 * Content Sync routes a user from Contentful to a page created from the entry data they're interested in previewing.
 */

function contentfulCreateNodeManifest({
  pluginConfig,
  entryItem,
  entryNode,
  space,
  unstable_createNodeManifest,
}) {
  const isPreview = pluginConfig.get(`host`) === `preview.contentful.com`

  const createNodeManifestIsSupported =
    typeof unstable_createNodeManifest === `function`

  const shouldCreateNodeManifest = isPreview && createNodeManifestIsSupported

  const updatedAt = entryItem.sys.updatedAt

  const manifestId = `${space.sys.id}-${entryItem.sys.id}-${updatedAt}`

  if (
    process.env.CONTENTFUL_DEBUG_NODE_MANIFEST === `true` &&
    numberOfContentSyncDebugLogs <= maxContentSyncDebugLogTimes
  ) {
    numberOfContentSyncDebugLogs++

    console.info(
      JSON.stringify({
        isPreview,
        createNodeManifestIsSupported,
        shouldCreateNodeManifest,
        manifestId,
        entryItemSysUpdatedAt: updatedAt,
      })
    )
  }

  if (shouldCreateNodeManifest) {
    if (shouldUpgradeGatsbyVersion && !warnOnceToUpgradeGatsby) {
      console.warn(
        `Your site is doing more work than it needs to for Preview, upgrade to Gatsby ^${GATSBY_VERSION_MANIFEST_V2} for better performance`
      )
      warnOnceToUpgradeGatsby = true
    }

    unstable_createNodeManifest({
      manifestId,
      node: entryNode,
      updatedAtUTC: updatedAt,
    })
  } else if (
    isPreview &&
    !createNodeManifestIsSupported &&
    !warnOnceForNoSupport
  ) {
    console.warn(
      `Contentful: Your version of Gatsby core doesn't support Content Sync (via the unstable_createNodeManifest action). Please upgrade to the latest version to use Content Sync in your site.`
    )
    warnOnceForNoSupport = true
  }
}

export const createContentTypeNodes = ({
  contentTypeMap,
  createNodeId,
  createNode,
}) => {
  const createContentTypePromises = []
  for (const {
    contentTypeItem,
    normalizedContentTypeId,
  } of contentTypeMap.values()) {
    // Create a node for each content type
    const contentTypeNode = {
      id: createNodeId(normalizedContentTypeId),
      parent: null,
      children: [],
      contentful_id: contentTypeItem.sys.id,
      name: contentTypeItem.name,
      displayField: contentTypeItem.displayField,
      description: contentTypeItem.description,
      internal: {
        type: `${makeTypeName(`ContentType`)}`,
      },
      sys: {
        type: contentTypeItem.sys.type,
      },
    }

    // The content of an entry is guaranteed to be updated if and only if the .sys.updatedAt field changed
    contentTypeNode.internal.contentDigest = contentTypeItem.sys.updatedAt

    createContentTypePromises.push(createNode(contentTypeNode))
  }
  return createContentTypePromises
}

export const createNodes = ({
  contentTypeMap,
  restrictedNodeFields,
  conflictFieldPrefix,
  entries,
  unstable_createNodeManifest,
  createNode,
  createNodeId,
  getNode,
  resolvable,
  foreignReferenceMap,
  defaultLocale,
  locales,
  space,
  pluginConfig,
}) => {
  const createNodePromises = []

  locales.forEach(locale => {
    const localesFallback = buildFallbackChain(locales)
    const mId = makeMakeId({
      currentLocale: locale.code,
      defaultLocale,
      createNodeId,
    })
    const getField = makeGetLocalizedField({
      locale,
      localesFallback,
    })

    const childrenNodes = []

    // First create nodes for each of the entries of that content type
    const entryNodes = entries
      .map(entryItem => {
        const { contentTypeItem, conflictFields, normalizedContentTypeId } =
          contentTypeMap.get(entryItem.sys.contentType.sys.id)
        const entryNodeId = mId(
          space.sys.id,
          entryItem.sys.id,
          entryItem.sys.type
        )

        const existingNode = getNode(entryNodeId)
        if (existingNode?.internal?.contentDigest === entryItem.sys.updatedAt) {
          // The Contentful model has `.sys.updatedAt` leading for an entry. If the updatedAt value
          // of an entry did not change, then we can trust that none of its children were changed either.
          return null
        }

        // Get localized fields.
        const entryItemFields = _.mapValues(entryItem.fields, (v, k) => {
          const fieldProps = contentTypeItem.fields.find(
            field => field.id === k
          )

          const localizedField = fieldProps.localized
            ? getField(v)
            : v[defaultLocale]

          return localizedField
        })

        // Prefix any conflicting fields
        // https://github.com/gatsbyjs/gatsby/pull/1084#pullrequestreview-41662888
        conflictFields.forEach(conflictField => {
          entryItemFields[`${conflictFieldPrefix}${conflictField}`] =
            entryItemFields[conflictField]
          delete entryItemFields[conflictField]
        })

        // Add linkages to other nodes based on foreign references
        Object.keys(entryItemFields).forEach(entryItemFieldKey => {
          if (entryItemFields[entryItemFieldKey]) {
            const entryItemFieldValue = entryItemFields[entryItemFieldKey]
            if (Array.isArray(entryItemFieldValue)) {
              if (entryItemFieldValue[0]?.sys?.type === `Link`) {
                // Check if there are any values in entryItemFieldValue to prevent
                // creating an empty node field in case when original key field value
                // is empty due to links to missing entities
                const resolvableEntryItemFieldValue = entryItemFieldValue
                  .filter(function (v) {
                    return resolvable.has(
                      `${v.sys.id}___${v.sys.linkType || v.sys.type}`
                    )
                  })
                  .map(function (v) {
                    return mId(
                      space.sys.id,
                      v.sys.id,
                      v.sys.linkType || v.sys.type
                    )
                  })
                if (resolvableEntryItemFieldValue.length !== 0) {
                  entryItemFields[`${entryItemFieldKey}___NODE`] =
                    resolvableEntryItemFieldValue
                }

                delete entryItemFields[entryItemFieldKey]
              }
            } else if (entryItemFieldValue?.sys?.type === `Link`) {
              if (
                resolvable.has(
                  `${entryItemFieldValue.sys.id}___${
                    entryItemFieldValue.sys.linkType ||
                    entryItemFieldValue.sys.type
                  }`
                )
              ) {
                entryItemFields[`${entryItemFieldKey}___NODE`] = mId(
                  space.sys.id,
                  entryItemFieldValue.sys.id,
                  entryItemFieldValue.sys.linkType ||
                    entryItemFieldValue.sys.type
                )
              }
              delete entryItemFields[entryItemFieldKey]
            }
          }
        })

        // Add reverse linkages if there are any for this node
        const foreignReferences =
          foreignReferenceMap[`${entryItem.sys.id}___${entryItem.sys.type}`]
        if (foreignReferences) {
          foreignReferences.forEach(foreignReference => {
            const existingReference = entryItemFields[foreignReference.name]
            if (existingReference) {
              // If the existing reference is a string, we're dealing with a
              // many-to-one reference which has already been recorded, so we can
              // skip it. However, if it is an array, add it:
              if (Array.isArray(existingReference)) {
                entryItemFields[foreignReference.name].push(
                  mId(
                    foreignReference.spaceId,
                    foreignReference.id,
                    foreignReference.type
                  )
                )
              }
            } else {
              // If there is one foreign reference, there can be many.
              // Best to be safe and put it in an array to start with.
              entryItemFields[foreignReference.name] = [
                mId(
                  foreignReference.spaceId,
                  foreignReference.id,
                  foreignReference.type
                ),
              ]
            }
          })
        }

        let entryNode = {
          id: entryNodeId,
          spaceId: space.sys.id,
          contentful_id: entryItem.sys.id,
          createdAt: entryItem.sys.createdAt,
          updatedAt: entryItem.sys.updatedAt,
          parent: normalizedContentTypeId,
          children: [],
          internal: {
            type: `${makeTypeName(normalizedContentTypeId)}`,
          },
          sys: {
            type: entryItem.sys.type,
          },
        }

        contentfulCreateNodeManifest({
          pluginConfig,
          entryItem,
          entryNode,
          space,
          unstable_createNodeManifest,
        })

        // Revision applies to entries, assets, and content types
        if (entryItem.sys.revision) {
          entryNode.sys.revision = entryItem.sys.revision
        }

        // Content type applies to entries only
        if (entryItem.sys.contentType) {
          entryNode.sys.contentType = entryItem.sys.contentType
        }

        // Replace text fields with text nodes so we can process their markdown
        // into HTML.
        Object.keys(entryItemFields).forEach(entryItemFieldKey => {
          // Ignore fields with "___node" as they're already handled
          // and won't be a text field.
          if (entryItemFieldKey.includes(`___`)) {
            return
          }

          const fieldType = contentTypeItem.fields.find(
            f =>
              (restrictedNodeFields.includes(f.id)
                ? `${conflictFieldPrefix}${f.id}`
                : f.id) === entryItemFieldKey
          ).type
          if (fieldType === `Text`) {
            const textNodeId = createNodeId(
              `${entryNodeId}${entryItemFieldKey}TextNode`
            )

            // The Contentful model has `.sys.updatedAt` leading for an entry. If the updatedAt value
            // of an entry did not change, then we can trust that none of its children were changed either.
            // (That's why child nodes use the updatedAt of the parent node as their digest, too)
            const existingNode = getNode(textNodeId)
            if (
              existingNode?.internal?.contentDigest !== entryItem.sys.updatedAt
            ) {
              const textNode = prepareTextNode(
                textNodeId,
                entryNode,
                entryItemFieldKey,
                entryItemFields[entryItemFieldKey]
              )

              childrenNodes.push(textNode)
            }

            entryItemFields[`${entryItemFieldKey}___NODE`] = textNodeId
            delete entryItemFields[entryItemFieldKey]
          } else if (
            fieldType === `RichText` &&
            _.isPlainObject(entryItemFields[entryItemFieldKey])
          ) {
            const fieldValue = entryItemFields[entryItemFieldKey]

            const rawReferences = []

            // Locate all Contentful Links within the rich text data
            const traverse = obj => {
              // eslint-disable-next-line guard-for-in
              for (const k in obj) {
                const v = obj[k]
                if (v && v.sys && v.sys.type === `Link`) {
                  rawReferences.push(v)
                } else if (v && typeof v === `object`) {
                  traverse(v)
                }
              }
            }

            traverse(fieldValue)

            // Build up resolvable reference list
            const resolvableReferenceIds = new Set()
            rawReferences
              .filter(function (v) {
                return resolvable.has(
                  `${v.sys.id}___${v.sys.linkType || v.sys.type}`
                )
              })
              .forEach(function (v) {
                resolvableReferenceIds.add(
                  mId(space.sys.id, v.sys.id, v.sys.linkType || v.sys.type)
                )
              })

            entryItemFields[entryItemFieldKey] = {
              raw: stringify(fieldValue),
              references___NODE: [...resolvableReferenceIds],
            }
          } else if (
            fieldType === `Object` &&
            _.isPlainObject(entryItemFields[entryItemFieldKey])
          ) {
            const jsonNodeId = createNodeId(
              `${entryNodeId}${entryItemFieldKey}JSONNode`
            )

            // The Contentful model has `.sys.updatedAt` leading for an entry. If the updatedAt value
            // of an entry did not change, then we can trust that none of its children were changed either.
            // (That's why child nodes use the updatedAt of the parent node as their digest, too)
            const existingNode = getNode(jsonNodeId)
            if (
              existingNode?.internal?.contentDigest !== entryItem.sys.updatedAt
            ) {
              const jsonNode = prepareJSONNode(
                jsonNodeId,
                entryNode,
                entryItemFieldKey,
                entryItemFields[entryItemFieldKey]
              )
              childrenNodes.push(jsonNode)
            }

            entryItemFields[`${entryItemFieldKey}___NODE`] = jsonNodeId
            delete entryItemFields[entryItemFieldKey]
          } else if (
            fieldType === `Object` &&
            _.isArray(entryItemFields[entryItemFieldKey])
          ) {
            entryItemFields[`${entryItemFieldKey}___NODE`] = []

            entryItemFields[entryItemFieldKey].forEach((obj, i) => {
              const jsonNodeId = createNodeId(
                `${entryNodeId}${entryItemFieldKey}${i}JSONNode`
              )

              // The Contentful model has `.sys.updatedAt` leading for an entry. If the updatedAt value
              // of an entry did not change, then we can trust that none of its children were changed either.
              // (That's why child nodes use the updatedAt of the parent node as their digest, too)
              const existingNode = getNode(jsonNodeId)
              if (
                existingNode?.internal?.contentDigest !==
                entryItem.sys.updatedAt
              ) {
                const jsonNode = prepareJSONNode(
                  jsonNodeId,
                  entryNode,
                  entryItemFieldKey,
                  obj
                )
                childrenNodes.push(jsonNode)
              }

              entryItemFields[`${entryItemFieldKey}___NODE`].push(jsonNodeId)
            })

            delete entryItemFields[entryItemFieldKey]
          }
        })

        entryNode = {
          ...entryItemFields,
          ...entryNode,
          node_locale: locale.code,
        }

        // The content of an entry is guaranteed to be updated if and only if the .sys.updatedAt field changed
        entryNode.internal.contentDigest = entryItem.sys.updatedAt

        // Link tags
        if (pluginConfig.get(`enableTags`)) {
          entryNode.metadata = {
            tags___NODE: entryItem.metadata.tags.map(tag =>
              createNodeId(`ContentfulTag__${space.sys.id}__${tag.sys.id}`)
            ),
          }
        }

        return entryNode
      })
      .filter(Boolean)

    entryNodes.forEach(entryNode => {
      createNodePromises.push(createNode(entryNode))
    })
    childrenNodes.forEach(entryNode => {
      createNodePromises.push(createNode(entryNode))
    })
  })

  return createNodePromises
}

export const createAssetNodes = ({
  assetItem,
  createNode,
  createNodeId,
  defaultLocale,
  locales,
  space,
  pluginConfig,
}) => {
  const createNodePromises = []
  locales.forEach(locale => {
    const localesFallback = buildFallbackChain(locales)
    const mId = makeMakeId({
      currentLocale: locale.code,
      defaultLocale,
      createNodeId,
    })
    const getField = makeGetLocalizedField({
      locale,
      localesFallback,
    })

    const assetNode = {
      contentful_id: assetItem.sys.id,
      spaceId: space.sys.id,
      id: mId(space.sys.id, assetItem.sys.id, assetItem.sys.type),
      createdAt: assetItem.sys.createdAt,
      updatedAt: assetItem.sys.updatedAt,
      parent: null,
      children: [],
      file: assetItem.fields.file ? getField(assetItem.fields.file) : null,
      title: assetItem.fields.title ? getField(assetItem.fields.title) : ``,
      description: assetItem.fields.description
        ? getField(assetItem.fields.description)
        : ``,
      node_locale: locale.code,
      internal: {
        type: `${makeTypeName(`Asset`)}`,
      },
      sys: {
        type: assetItem.sys.type,
      },
    }

    // Link tags
    if (pluginConfig.get(`enableTags`)) {
      assetNode.metadata = {
        tags___NODE: assetItem.metadata.tags.map(tag =>
          createNodeId(`ContentfulTag__${space.sys.id}__${tag.sys.id}`)
        ),
      }
    }

    // Revision applies to entries, assets, and content types
    if (assetItem.sys.revision) {
      assetNode.sys.revision = assetItem.sys.revision
    }

    // The content of an entry is guaranteed to be updated if and only if the .sys.updatedAt field changed
    assetNode.internal.contentDigest = assetItem.sys.updatedAt

    // if the node hasn't changed, createNode may return `undefined` instead of a Promise on some versions of Gatsby
    const maybePromise = createNode(assetNode)

    createNodePromises.push(
      maybePromise?.then ? maybePromise.then(() => assetNode) : assetNode
    )
  })

  return createNodePromises
}
